<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nexus AI Studio - Advanced Video Generator</title>
  <style>
    :root {
      --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --accent-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      --success-gradient: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
      --glass-bg: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.2);
      --text-primary: #ffffff;
      --text-secondary: rgba(255, 255, 255, 0.8);
      --shadow-main: 0 25px 50px rgba(0, 0, 0, 0.3);
      --shadow-glow: 0 0 30px rgba(102, 126, 234, 0.3);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: 
        radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.2) 0%, transparent 50%),
        linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
      color: var(--text-primary);
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="1" fill="rgba(255,255,255,0.1)"/></svg>') repeat,
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50"><circle cx="25" cy="25" r="0.5" fill="rgba(255,255,255,0.05)"/></svg>') repeat;
      background-size: 100px 100px, 50px 50px;
      animation: stars 20s linear infinite;
      pointer-events: none;
      z-index: -1;
    }

    @keyframes stars {
      0% { transform: translateY(0); }
      100% { transform: translateY(-100px); }
    }

    .loading-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      transition: opacity 0.5s ease;
    }

    .loading-spinner {
      width: 80px;
      height: 80px;
      border: 3px solid rgba(255, 255, 255, 0.1);
      border-top: 3px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      position: relative;
      z-index: 1;
    }

    .header {
      text-align: center;
      margin-bottom: 50px;
      position: relative;
    }

    .logo {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
    }

    .logo-icon {
      width: 60px;
      height: 60px;
      background: var(--primary-gradient);
      border-radius: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      box-shadow: var(--shadow-glow);
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }

    h1 {
      font-size: 3.5rem;
      font-weight: 800;
      background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57);
      background-size: 400% 400%;
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradientShift 6s ease infinite;
      margin-bottom: 10px;
      letter-spacing: -2px;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .subtitle {
      font-size: 1.3rem;
      color: var(--text-secondary);
      margin-bottom: 20px;
      font-weight: 300;
    }

    .features-badge {
      display: inline-flex;
      gap: 20px;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 50px;
      padding: 10px 25px;
      font-size: 0.9rem;
      margin-bottom: 30px;
    }

    .badge-item {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-secondary);
    }

    .main-layout {
      display: grid;
      grid-template-columns: 380px 1fr 300px;
      gap: 30px;
      align-items: start;
    }

    .control-panel, .preview-panel, .timeline-panel {
      background: var(--glass-bg);
      backdrop-filter: blur(25px);
      border: 1px solid var(--glass-border);
      border-radius: 25px;
      padding: 30px;
      box-shadow: var(--shadow-main);
      position: relative;
      overflow: hidden;
    }

    .control-panel::before, .preview-panel::before, .timeline-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
    }

    .section-title {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 25px;
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--text-primary);
    }

    .section-icon {
      width: 28px;
      height: 28px;
      background: var(--accent-gradient);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .upload-zone {
      border: 2px dashed var(--glass-border);
      border-radius: 20px;
      padding: 30px;
      text-align: center;
      margin-bottom: 25px;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.02);
    }

    .upload-zone::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(from 0deg, transparent, rgba(102, 126, 234, 0.1), transparent);
      animation: rotate 10s linear infinite;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .upload-zone:hover::before {
      opacity: 1;
    }

    .upload-zone.drag-over {
      border-color: #4ecdc4;
      background: rgba(78, 205, 196, 0.1);
      transform: scale(1.02);
    }

    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .upload-icon {
      font-size: 48px;
      margin-bottom: 15px;
      background: var(--primary-gradient);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .upload-text {
      font-size: 1.1rem;
      margin-bottom: 10px;
      font-weight: 600;
    }

    .upload-subtext {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .file-input {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .media-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
      gap: 12px;
      margin-top: 20px;
      max-height: 280px;
      overflow-y: auto;
      padding: 5px;
    }

    .media-item {
      position: relative;
      aspect-ratio: 1;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid var(--glass-border);
      transition: all 0.3s ease;
      cursor: pointer;
      background: var(--glass-bg);
    }

    .media-item:hover {
      border-color: #4ecdc4;
      transform: scale(1.05);
      box-shadow: 0 10px 25px rgba(78, 205, 196, 0.3);
    }

    .media-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .media-item .remove-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 20px;
      height: 20px;
      background: rgba(255, 107, 107, 0.9);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .media-item:hover .remove-btn {
      opacity: 1;
    }

    .controls-section {
      margin-bottom: 30px;
    }

    .control-group {
      margin-bottom: 20px;
    }

    .control-label {
      display: block;
      font-size: 0.95rem;
      font-weight: 600;
      margin-bottom: 10px;
      color: var(--text-primary);
    }

    .control-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 15px;
    }

    select, input[type="range"], input[type="number"] {
      width: 100%;
      padding: 12px 15px;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      color: var(--text-primary);
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s ease;
    }

    select:focus, input:focus {
      outline: none;
      border-color: #4ecdc4;
      background: rgba(255, 255, 255, 0.12);
      box-shadow: 0 0 0 3px rgba(78, 205, 196, 0.2);
    }

    select option {
      background: #2a2a3e;
      color: var(--text-primary);
      padding: 10px;
    }

    .range-container {
      position: relative;
    }

    .range-value {
      position: absolute;
      top: -25px;
      right: 0;
      font-size: 0.8rem;
      color: #4ecdc4;
      font-weight: 600;
    }

    input[type="range"] {
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--accent-gradient);
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(79, 172, 254, 0.4);
      transition: all 0.3s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 6px 20px rgba(79, 172, 254, 0.6);
    }

    .ai-effects {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 25px;
    }

    .effects-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }

    .effect-toggle {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }

    .effect-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--glass-border);
    }

    .effect-toggle.active {
      background: rgba(78, 205, 196, 0.2);
      border-color: #4ecdc4;
    }

    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      transition: all 0.3s ease;
    }

    .toggle-switch::before {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: all 0.3s ease;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }

    .effect-toggle.active .toggle-switch {
      background: var(--accent-gradient);
    }

    .effect-toggle.active .toggle-switch::before {
      transform: translateX(20px);
    }

    .effect-name {
      font-weight: 600;
      font-size: 0.9rem;
    }

    .button-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 20px;
    }

    .btn {
      padding: 16px 24px;
      border: none;
      border-radius: 15px;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.6s;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn-primary {
      background: var(--secondary-gradient);
      color: white;
      box-shadow: 0 10px 25px rgba(245, 87, 108, 0.3);
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: 0 15px 35px rgba(245, 87, 108, 0.4);
    }

    .btn-secondary {
      background: var(--primary-gradient);
      color: white;
      box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
    }

    .btn-secondary:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
    }

    .btn-success {
      background: var(--success-gradient);
      color: white;
      width: 100%;
      margin-top: 10px;
      font-size: 18px;
      padding: 20px;
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }

    .canvas-container {
      position: relative;
      background: var(--glass-bg);
      backdrop-filter: blur(25px);
      border: 1px solid var(--glass-border);
      border-radius: 25px;
      padding: 25px;
      text-align: center;
      box-shadow: var(--shadow-main);
    }

    .canvas-wrapper {
      position: relative;
      display: inline-block;
      border-radius: 20px;
      overflow: hidden;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
    }

    canvas {
      display: block;
      max-width: 100%;
      height: auto;
      background: linear-gradient(45deg, #0a0a0a, #1a1a1a);
    }

    .canvas-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }

    .recording-indicator {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(255, 68, 68, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .recording-indicator.active {
      opacity: 1;
      animation: pulse-red 1.5s infinite;
    }

    .recording-dot {
      width: 8px;
      height: 8px;
      background: white;
      border-radius: 50%;
      animation: blink 1s infinite;
    }

    @keyframes pulse-red {
      0%, 100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.4); }
      50% { box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); }
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    .progress-container {
      margin: 20px 0;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .progress-container.visible {
      opacity: 1;
    }

    .progress-bar {
      width: 100%;
      height: 10px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: var(--accent-gradient);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 5px;
      position: relative;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .timeline-panel {
      padding: 25px;
    }

    .timeline-container {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 20px;
      margin-bottom: 20px;
    }

    .timeline-track {
      height: 60px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 8px;
      position: relative;
      margin-bottom: 15px;
      overflow: hidden;
    }

    .timeline-items {
      display: flex;
      height: 100%;
      gap: 2px;
    }

    .timeline-item {
      flex: 1;
      background: var(--primary-gradient);
      border-radius: 4px;
      position: relative;
      min-width: 40px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .timeline-item:hover {
      transform: scaleY(1.1);
      filter: brightness(1.2);
    }

    .timeline-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 4px;
    }

    .playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 3px;
      background: #ff4444;
      transition: left 0.1s ease;
      border-radius: 2px;
      box-shadow: 0 0 10px rgba(255, 68, 68, 0.6);
    }

    .status-panel {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 20px;
      text-align: center;
      border-left: 4px solid var(--accent-gradient);
    }

    .status-icon {
      font-size: 2rem;
      margin-bottom: 10px;
    }

    .status-text {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 5px;
    }

    .status-subtext {
      font-size: 0.85rem;
      color: var(--text-secondary);
      line-height: 1.4;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-top: 20px;
    }

    .stat-item {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: 700;
      color: #4ecdc4;
      margin-bottom: 5px;
    }

    .stat-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
    }

    .audio-visualizer {
      height: 40px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      margin: 15px 0;
      position: relative;
      overflow: hidden;
    }

    .visualizer-bars {
      display: flex;
      align-items: end;
      height: 100%;
      gap: 2px;
      padding: 5px;
    }

    .visualizer-bar {
      flex: 1;
      background: var(--accent-gradient);
      border-radius: 2px;
      min-height: 2px;
      transition: height 0.1s ease;
    }

    .export-options {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 15px;
      padding: 20px;
      margin-top: 20px;
    }

    .quality-selector {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-bottom: 15px;
    }

    .quality-option {
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--glass-border);
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .quality-option:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: #4ecdc4;
    }

    .quality-option.selected {
      background: rgba(78, 205, 196, 0.2);
      border-color: #4ecdc4;
    }

    .quality-label {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 2px;
    }

    .quality-res {
      font-size: 0.7rem;
      color: var(--text-secondary);
    }

    @media (max-width: 1200px) {
      .main-layout {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .control-panel, .timeline-panel {
        order: 2;
      }
      
      .preview-panel {
        order: 1;
      }
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 2.5rem;
      }
      
      .control-row {
        grid-template-columns: 1fr;
      }
      
      .button-grid {
        grid-template-columns: 1fr;
      }
      
      .effects-grid {
        grid-template-columns: 1fr;
      }
      
      .features-badge {
        flex-direction: column;
        gap: 10px;
      }
    }

    .tooltip {
      position: relative;
      cursor: help;
    }

    .tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.8rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
      z-index: 1000;
    }

    .tooltip:hover::after {
      opacity: 1;
    }

    .fade-in {
      animation: fadeIn 0.6s ease-in-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .slide-in {
      animation: slideIn 0.8s ease-out;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-30px); }
      to { opacity: 1; transform: translateX(0); }
    }
  </style>
</head>
<body>
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-spinner"></div>
  </div>

  <div class="container">
    <div class="header fade-in">
      <div class="logo">
        <div class="logo-icon">🎬</div>
        <h1>Nexus AI Studio</h1>
      </div>
      <p class="subtitle">Professional AI-Powered Video Generation Platform</p>
      <div class="features-badge">
        <div class="badge-item">
          <span>🤖</span>
          <span>AI-Powered</span>
        </div>
        <div class="badge-item">
          <span>⚡</span>
          <span>Real-time</span>
        </div>
        <div class="badge-item">
          <span>🎨</span>
          <span>Professional</span>
        </div>
        <div class="badge-item">
          <span>📱</span>
          <span>Cross-Platform</span>
        </div>
      </div>
    </div>

    <div class="main-layout">
      <!-- Control Panel -->
      <div class="control-panel slide-in">
        <div class="section-title">
          <div class="section-icon">📁</div>
          Media Library
        </div>

        <!-- Image Upload -->
        <div class="upload-zone" id="imageUploadZone">
          <input type="file" id="imageInput" class="file-input" accept="image/*" multiple />
          <div class="upload-icon">🖼️</div>
          <div class="upload-text">Drop images here</div>
          <div class="upload-subtext">or click to browse • Support: JPG, PNG, WebP, GIF</div>
        </div>

        <div class="media-grid" id="imageGrid"></div>

        <!-- Audio Upload -->
        <div class="upload-zone" id="audioUploadZone" style="margin-top: 20px;">
          <input type="file" id="audioInput" class="file-input" accept="audio/*" />
          <div class="upload-icon">🎵</div>
          <div class="upload-text">Add background music</div>
          <div class="upload-subtext">Support: MP3, WAV, OGG, M4A</div>
        </div>

        <div class="audio-visualizer" id="audioVisualizer" style="display: none;">
          <div class="visualizer-bars" id="visualizerBars"></div>
        </div>

        <!-- AI Controls -->
        <div class="controls-section">
          <div class="section-title">
            <div class="section-icon">⚙️</div>
            Generation Settings
          </div>

          <div class="control-group">
            <label class="control-label">Duration & Timing</label>
            <div class="control-row">
              <select id="durationSelect">
                <option value="1">1 second</option>
                <option value="2">2 seconds</option>
                <option value="3" selected>3 seconds</option>
                <option value="4">4 seconds</option>
                <option value="5">5 seconds</option>
                <option value="7">7 seconds</option>
                <option value="10">10 seconds</option>
              </select>
              <div class="range-container">
                <input type="range" id="transitionDuration" min="0.2" max="3" step="0.1" value="1" />
                <div class="range-value" id="transitionValue">1.0s</div>
              </div>
            </div>
          </div>

          <div class="control-group">
            <label class="control-label">AI Transition Engine</label>
            <select id="transitionSelect">
              <option value="ai-smart">🤖 AI Smart Selection</option>
              <option value="crossfade">✨ Crossfade</option>
              <option value="slide-left">← Slide Left</option>
              <option value="slide-right">→ Slide Right</option>
              <option value="slide-up">↑ Slide Up</option>
              <option value="slide-down">↓ Slide Down</option>
              <option value="zoom-in">🔍 Zoom In</option>
              <option value="zoom-out">🔎 Zoom Out</option>
              <option value="rotate">🔄 Rotate</option>
              <option value="blur">🌀 Blur Transition</option>
              <option value="pixelate">🎮 Pixelate</option>
              <option value="glitch">⚡ Glitch Effect</option>
              <option value="wipe">📱 Wipe</option>
              <option value="iris">👁️ Iris</option>
            </select>
          </div>

          <div class="control-group">
            <label class="control-label">Video Quality</label>
            <div class="quality-selector">
              <div class="quality-option" data-quality="720p">
                <div class="quality-label">HD</div>
                <div class="quality-res">720p</div>
              </div>
              <div class="quality-option selected" data-quality="1080p">
                <div class="quality-label">Full HD</div>
                <div class="quality-res">1080p</div>
              </div>
              <div class="quality-option" data-quality="4k">
                <div class="quality-label">Ultra HD</div>
                <div class="quality-res">4K</div>
              </div>
            </div>
          </div>
        </div>

        <!-- AI Effects -->
        <div class="ai-effects">
          <div class="section-title">
            <div class="section-icon">✨</div>
            AI Enhancement Suite
          </div>
          
          <div class="effects-grid">
            <div class="effect-toggle tooltip" data-tooltip="Enhance colors and contrast automatically">
              <div class="toggle-switch"></div>
              <div class="effect-name">Color Grading</div>
            </div>
            <div class="effect-toggle tooltip" data-tooltip="Add cinematic motion blur">
              <div class="toggle-switch"></div>
              <div class="effect-name">Motion Blur</div>
            </div>
            <div class="effect-toggle tooltip" data-tooltip="Apply film-style vignette">
              <div class="toggle-switch"></div>
              <div class="effect-name">Vignette</div>
            </div>
            <div class="effect-toggle tooltip" data-tooltip="Add vintage film grain">
              <div class="toggle-switch"></div>
              <div class="effect-name">Film Grain</div>
            </div>
            <div class="effect-toggle tooltip" data-tooltip="Stabilize shaky footage">
              <div class="toggle-switch"></div>
              <div class="effect-name">Stabilization</div>
            </div>
            <div class="effect-toggle tooltip" data-tooltip="Enhance low-light images">
              <div class="toggle-switch"></div>
              <div class="effect-name">Night Vision</div>
            </div>
            <div class="effect-toggle tooltip" data-tooltip="Add depth of field blur">
              <div class="toggle-switch"></div>
              <div class="effect-name">Depth Blur</div>
            </div>
            <div class="effect-toggle tooltip" data-tooltip="Automatic face enhancement">
              <div class="toggle-switch"></div>
              <div class="effect-name">Face Enhance</div>
            </div>
          </div>
        </div>

        <!-- Action Buttons -->
        <div class="button-grid">
          <button class="btn btn-primary" id="startBtn">
            <span>🎬</span>
            <span>Generate</span>
          </button>
          <button class="btn btn-secondary" id="stopBtn" disabled>
            <span>⏹</span>
            <span>Stop</span>
          </button>
        </div>

        <button class="btn btn-success" id="downloadBtn" style="display:none;">
          <span>📥</span>
          <span>Download Video</span>
        </button>

        <div class="progress-container" id="progressContainer">
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
          </div>
        </div>
      </div>

      <!-- Preview Panel -->
      <div class="preview-panel fade-in">
        <div class="section-title">
          <div class="section-icon">🎥</div>
          Live Preview
        </div>

        <div class="canvas-container">
          <div class="canvas-wrapper">
            <canvas id="canvas" width="1920" height="1080"></canvas>
            <div class="canvas-overlay">
              <div class="recording-indicator" id="recordingIndicator">
                <div class="recording-dot"></div>
                <span>Recording</span>
              </div>
            </div>
          </div>
        </div>

        <div class="export-options">
          <div class="section-title" style="margin-bottom: 15px;">
            <div class="section-icon">⚙️</div>
            Export Settings
          </div>
          
          <div class="control-row">
            <select id="formatSelect">
              <option value="mp4">MP4 (Recommended)</option>
              <option value="webm">WebM (Smaller Size)</option>
              <option value="mov">MOV (Professional)</option>
              <option value="gif">GIF (Animation)</option>
            </select>
            <select id="fpsSelect">
              <option value="24">24 FPS (Cinematic)</option>
              <option value="30" selected>30 FPS (Standard)</option>
              <option value="60">60 FPS (Smooth)</option>
            </select>
          </div>

          <div class="control-group">
            <label class="control-label">Video Bitrate</label>
            <div class="range-container">
              <input type="range" id="bitrateRange" min="1" max="10" step="0.5" value="5" />
              <div class="range-value" id="bitrateValue">5.0 Mbps</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Timeline Panel -->
      <div class="timeline-panel slide-in">
        <div class="section-title">
          <div class="section-icon">⏱️</div>
          Timeline & Stats
        </div>

        <div class="timeline-container">
          <div class="timeline-track" id="timelineTrack">
            <div class="timeline-items" id="timelineItems"></div>
            <div class="playhead" id="playhead"></div>
          </div>
        </div>

        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value" id="imageCount">0</div>
            <div class="stat-label">Images</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="totalDuration">0s</div>
            <div class="stat-label">Duration</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="effectsCount">0</div>
            <div class="stat-label">Effects</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="qualityLevel">HD</div>
            <div class="stat-label">Quality</div>
          </div>
        </div>

        <div class="status-panel">
          <div class="status-icon" id="statusIcon">🚀</div>
          <div class="status-text" id="statusText">Ready to create magic!</div>
          <div class="status-subtext" id="statusSubtext">
            Upload your images and let our AI create something amazing.
            <br><br>
            <strong>💡 Pro Tips:</strong><br>
            • Use high-resolution images for best quality<br>
            • Try different transition styles for unique effects<br>
            • Enable AI effects for professional results<br>
            • Add music to enhance the experience
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Initialize application
    class NexusAIStudio {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.images = [];
        this.audioBuffer = null;
        this.audioCtx = null;
        this.sourceNode = null;
        this.analyserNode = null;
        this.isRecording = false;
        this.currentTime = 0;
        this.animationId = null;
        this.mediaRecorder = null;
        this.videoChunks = [];
        this.settings = {
          duration: 3,
          transitionDuration: 1,
          transition: 'ai-smart',
          quality: '1080p',
          format: 'mp4',
          fps: 30,
          bitrate: 5,
          effects: new Set()
        };
        
        // Performance optimization caches
        this._transitionCache = new Map();
        this._visualizerData = null;
        this._vignetteGradient = null;
        this._lastVisualizerUpdate = 0;
        this._lastPlayheadUpdate = 0;
        this._lastRenderedImage = -1;
        this._welcomeRendered = false;
        
        // Use OffscreenCanvas for analysis if available
        this.analysisCanvas = typeof OffscreenCanvas !== 'undefined' ? 
          new OffscreenCanvas(50, 50) : 
          document.createElement('canvas');
        this.analysisCtx = this.analysisCanvas.getContext('2d');
        if (this.analysisCanvas.width) {
          this.analysisCanvas.width = 50;
          this.analysisCanvas.height = 50;
        }
        
        this.init();
      }

      async init() {
        this.setupEventListeners();
        this.setupDragAndDrop();
        this.setupKeyboardShortcuts();
        this.initCanvas();
        this.createVisualizerBars();
        
        // Hide loading screen
        setTimeout(() => {
          document.getElementById('loadingScreen').style.opacity = '0';
          setTimeout(() => {
            document.getElementById('loadingScreen').style.display = 'none';
          }, 500);
        }, 1500);
      }

      setupEventListeners() {
        // File inputs
        document.getElementById('imageInput').addEventListener('change', (e) => this.handleImageUpload(e));
        document.getElementById('audioInput').addEventListener('change', (e) => this.handleAudioUpload(e));

        // Controls
        document.getElementById('durationSelect').addEventListener('change', (e) => {
          this.settings.duration = parseInt(e.target.value);
          this.updateStats();
        });

        document.getElementById('transitionDuration').addEventListener('input', (e) => {
          this.settings.transitionDuration = parseFloat(e.target.value);
          document.getElementById('transitionValue').textContent = e.target.value + 's';
        });

        document.getElementById('transitionSelect').addEventListener('change', (e) => {
          this.settings.transition = e.target.value;
        });

        document.getElementById('bitrateRange').addEventListener('input', (e) => {
          this.settings.bitrate = parseFloat(e.target.value);
          document.getElementById('bitrateValue').textContent = e.target.value + ' Mbps';
        });

        // Quality selector
        document.querySelectorAll('.quality-option').forEach(option => {
          option.addEventListener('click', (e) => {
            document.querySelectorAll('.quality-option').forEach(o => o.classList.remove('selected'));
            e.target.classList.add('selected');
            this.settings.quality = e.target.dataset.quality;
            this.updateCanvasSize();
            this.updateStats();
          });
        });

        // Effect toggles
        document.querySelectorAll('.effect-toggle').forEach(toggle => {
          toggle.addEventListener('click', () => {
            toggle.classList.toggle('active');
            const effectName = toggle.querySelector('.effect-name').textContent.toLowerCase().replace(' ', '');
            
            if (toggle.classList.contains('active')) {
              this.settings.effects.add(effectName);
            } else {
              this.settings.effects.delete(effectName);
            }
            this.updateStats();
          });
        });

        // Action buttons
        document.getElementById('startBtn').addEventListener('click', () => this.startGeneration());
        document.getElementById('stopBtn').addEventListener('click', () => this.stopGeneration());
      }

      setupDragAndDrop() {
        const zones = ['imageUploadZone', 'audioUploadZone'];
        
        zones.forEach(zoneId => {
          const zone = document.getElementById(zoneId);
          
          ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            zone.addEventListener(eventName, this.preventDefaults, false);
          });

          ['dragenter', 'dragover'].forEach(eventName => {
            zone.addEventListener(eventName, () => zone.classList.add('drag-over'), false);
          });

          ['dragleave', 'drop'].forEach(eventName => {
            zone.addEventListener(eventName, () => zone.classList.remove('drag-over'), false);
          });

          zone.addEventListener('drop', (e) => this.handleDrop(e, zoneId), false);
        });
      }

      preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      async handleDrop(e, zoneId) {
        const files = [...e.dataTransfer.files];
        
        if (zoneId === 'imageUploadZone') {
          const imageFiles = files.filter(file => file.type.startsWith('image/'));
          if (imageFiles.length > 0) {
            await this.loadImages(imageFiles);
          }
        } else if (zoneId === 'audioUploadZone') {
          const audioFiles = files.filter(file => file.type.startsWith('audio/'));
          if (audioFiles.length > 0) {
            await this.loadAudio(audioFiles[0]);
          }
        }
      }

      async handleImageUpload(e) {
        const files = [...e.target.files];
        if (files.length > 0) {
          await this.loadImages(files);
        }
      }

      async handleAudioUpload(e) {
        const file = e.target.files[0];
        if (file) {
          await this.loadAudio(file);
        }
      }

      async loadImages(files) {
        this.updateStatus('🔄', 'Loading images...', `Processing ${files.length} files`);
        
        const loadPromises = files.map(file => this.loadImageFile(file));
        const loadedImages = await Promise.all(loadPromises);
        
        this.images = [...this.images, ...loadedImages.filter(img => img !== null)];
        this.updateImageGrid();
        this.updateTimeline();
        this.updateStats();
        
        this.updateStatus('✅', 'Images loaded successfully!', `${this.images.length} images ready for generation`);
      }

      loadImageFile(file) {
        return new Promise((resolve) => {
          const img = new Image();
          const url = URL.createObjectURL(file);
          
          img.onload = () => {
            img.file = file;
            img.url = url;
            resolve(img);
          };
          
          img.onerror = () => {
            console.error('Failed to load image:', file.name);
            URL.revokeObjectURL(url);
            resolve(null);
          };
          
          img.src = url;
        });
      }

      async loadAudio(file) {
        this.updateStatus('🎵', 'Loading audio...', `Processing ${file.name}`);
        
        try {
          if (!this.audioCtx) {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }
          
          const arrayBuffer = await file.arrayBuffer();
          this.audioBuffer = await this.audioCtx.decodeAudioData(arrayBuffer);
          
          document.getElementById('audioVisualizer').style.display = 'block';
          this.setupAudioAnalyser();
          
          this.updateStatus('🎵', 'Audio loaded!', `${file.name} ready for playback`);
        } catch (error) {
          console.error('Audio loading error:', error);
          this.updateStatus('❌', 'Audio loading failed', 'Please try a different audio file');
        }
      }

      updateImageGrid() {
        const grid = document.getElementById('imageGrid');
        grid.innerHTML = '';
        
        this.images.forEach((img, index) => {
          const item = document.createElement('div');
          item.className = 'media-item';
          item.innerHTML = `
            <img src="${img.src}" alt="Image ${index + 1}" />
            <div class="remove-btn" onclick="nexusStudio.removeImage(${index})">×</div>
          `;
          grid.appendChild(item);
        });
      }

      removeImage(index) {
        if (this.images[index]) {
          URL.revokeObjectURL(this.images[index].url);
          this.images.splice(index, 1);
          this.updateImageGrid();
          this.updateTimeline();
          this.updateStats();
        }
      }

      updateTimeline() {
        const container = document.getElementById('timelineItems');
        container.innerHTML = '';
        
        this.images.forEach((img, index) => {
          const item = document.createElement('div');
          item.className = 'timeline-item';
          item.innerHTML = `<img src="${img.src}" alt="Frame ${index + 1}" />`;
          item.addEventListener('click', () => this.seekToFrame(index));
          container.appendChild(item);
        });
      }

      seekToFrame(index) {
        if (!this.isRecording) {
          this.currentTime = index * this.settings.duration;
          this.updatePlayhead();
          this.renderFrame();
        }
      }

      updatePlayhead() {
        const playhead = document.getElementById('playhead');
        const totalDuration = this.images.length * this.settings.duration;
        const progress = totalDuration > 0 ? (this.currentTime % totalDuration) / totalDuration : 0;
        playhead.style.left = `${progress * 100}%`;
      }

      updateStats() {
        document.getElementById('imageCount').textContent = this.images.length;
        document.getElementById('totalDuration').textContent = `${this.images.length * this.settings.duration}s`;
        document.getElementById('effectsCount').textContent = this.settings.effects.size;
        document.getElementById('qualityLevel').textContent = this.settings.quality.toUpperCase();
      }

      updateCanvasSize() {
        const sizes = {
          '720p': { width: 1280, height: 720 },
          '1080p': { width: 1920, height: 1080 },
          '4k': { width: 3840, height: 2160 }
        };
        
        const size = sizes[this.settings.quality];
        this.canvas.width = size.width;
        this.canvas.height = size.height;
        
        // Maintain aspect ratio for display
        const maxDisplayWidth = 800;
        const scale = Math.min(maxDisplayWidth / size.width, 600 / size.height);
        this.canvas.style.width = `${size.width * scale}px`;
        this.canvas.style.height = `${size.height * scale}px`;
      }

      initCanvas() {
        this.updateCanvasSize();
        this.renderWelcomeScreen();
      }

      renderWelcomeScreen() {
        const ctx = this.ctx;
        const { width, height } = this.canvas;
        
        // Gradient background
        const gradient = ctx.createLinearGradient(0, 0, width, height);
        gradient.addColorStop(0, '#667eea');
        gradient.addColorStop(0.5, '#764ba2');
        gradient.addColorStop(1, '#f093fb');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
        
        // Overlay pattern
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        for (let i = 0; i < 100; i++) {
          const x = Math.random() * width;
          const y = Math.random() * height;
          const size = Math.random() * 3;
          ctx.fillRect(x, y, size, size);
        }
        
        // Welcome text
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.textAlign = 'center';
        
        ctx.font = `bold ${width * 0.04}px Inter`;
        ctx.fillText('Nexus AI Studio', width / 2, height / 2 - 40);
        
        ctx.font = `${width * 0.02}px Inter`;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fillText('Upload images to begin creating', width / 2, height / 2 + 20);
        ctx.fillText('Professional AI-powered video generation', width / 2, height / 2 + 50);
      }

      createVisualizerBars() {
        const container = document.getElementById('visualizerBars');
        container.innerHTML = '';
        
        for (let i = 0; i < 32; i++) {
          const bar = document.createElement('div');
          bar.className = 'visualizer-bar';
          container.appendChild(bar);
        }
      }

      setupAudioAnalyser() {
        if (!this.audioCtx || !this.audioBuffer) return;
        
        this.analyserNode = this.audioCtx.createAnalyser();
        this.analyserNode.fftSize = 64;
        this.analyserNode.smoothingTimeConstant = 0.8;
      }

      updateAudioVisualizer() {
        if (!this.analyserNode) return;
        
        // Throttle updates to 20fps for performance
        if (!this._lastVisualizerUpdate || Date.now() - this._lastVisualizerUpdate > 50) {
          this._lastVisualizerUpdate = Date.now();
          
          if (!this._visualizerData) {
            this._visualizerData = new Uint8Array(this.analyserNode.frequencyBinCount);
          }
          
          this.analyserNode.getByteFrequencyData(this._visualizerData);
          
          const bars = document.querySelectorAll('.visualizer-bar');
          const dataArray = this._visualizerData;
          
          // Use requestAnimationFrame for smooth updates
          requestAnimationFrame(() => {
            bars.forEach((bar, index) => {
              const value = dataArray[index] || 0;
              const height = Math.max(2, (value / 255) * 100);
              bar.style.height = `${height}%`;
            });
          });
        }
      }

      analyzeImageContent(img) {
        // Use cached analysis if available
        if (img._analysis) return img._analysis;
        
        // Create offscreen canvas for better performance
        if (!this.analysisCanvas) {
          this.analysisCanvas = new OffscreenCanvas(50, 50);
          this.analysisCtx = this.analysisCanvas.getContext('2d');
        }
        
        const ctx = this.analysisCtx;
        ctx.drawImage(img, 0, 0, 50, 50);
        const imageData = ctx.getImageData(0, 0, 50, 50);
        const data = imageData.data;
        
        let brightness = 0;
        let colorfulness = 0;
        const len = data.length;
        
        // Optimized analysis loop
        for (let i = 0; i < len; i += 16) { // Sample every 4th pixel for speed
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          
          brightness += (r + g + b) * 0.333;
          colorfulness += Math.abs(r - g) + Math.abs(g - b) + Math.abs(b - r);
        }
        
        const pixelCount = len / 16;
        brightness /= (pixelCount * 255);
        colorfulness /= (pixelCount * 255);
        
        const analysis = {
          brightness,
          colorfulness,
          aspectRatio: img.width / img.height,
          isPortrait: img.height > img.width,
          isLandscape: img.width > img.height
        };
        
        // Cache the result
        img._analysis = analysis;
        return analysis;
      }

      selectSmartTransition(currentImg, nextImg) {
        const current = this.analyzeImageContent(currentImg);
        const next = this.analyzeImageContent(nextImg);
        
        const brightnessDiff = Math.abs(current.brightness - next.brightness);
        const colorfulnessDiff = Math.abs(current.colorfulness - next.colorfulness);
        const orientationChange = current.isPortrait !== next.isPortrait;
        
        // AI-based transition selection
        if (brightnessDiff > 0.4) return 'blur';
        if (orientationChange) return 'zoom-in';
        if (colorfulnessDiff > 0.3) return 'slide-left';
        if (current.colorfulness > 0.5 && next.colorfulness > 0.5) return 'crossfade';
        if (current.brightness < 0.3 || next.brightness < 0.3) return 'wipe';
        
        return 'crossfade'; // Default
      }

      applyAIEffects(imageData) {
        if (!this.settings.effects.size) return imageData;
        
        const data = imageData.data;
        const effects = this.settings.effects;
        const len = data.length;
        
        // Pre-calculate constants
        const hasColorGrading = effects.has('colorgrading');
        const hasFilmGrain = effects.has('filmgrain');
        const hasNightVision = effects.has('nightvision');
        
        // Use typed array for better performance
        const result = new Uint8ClampedArray(data);
        
        for (let i = 0; i < len; i += 4) {
          let r = result[i];
          let g = result[i + 1];
          let b = result[i + 2];
          
          // Color grading - optimized
          if (hasColorGrading) {
            r = (r * 1.1 + 5) | 0;
            g = (g * 1.05 + 3) | 0;
            b = (b * 0.95 + 2) | 0;
          }
          
          // Film grain - cached random values
          if (hasFilmGrain) {
            const noise = (Math.random() - 0.5) * 15;
            r = (r + noise) | 0;
            g = (g + noise) | 0;
            b = (b + noise) | 0;
          }
          
          // Night vision - optimized brightness calculation
          if (hasNightVision) {
            const brightness = (r * 0.299 + g * 0.587 + b * 0.114) | 0;
            if (brightness < 100) {
              r = (r * 1.5) | 0;
              g = (g * 1.5) | 0;
              b = (b * 1.5) | 0;
            }
          }
          
          result[i] = r;
          result[i + 1] = g;
          result[i + 2] = b;
        }
        
        return new ImageData(result, imageData.width, imageData.height);
      }

      drawImageWithEffects(img, alpha, effects = {}) {
        if (!img) return;
        
        const ctx = this.ctx;
        const { width, height } = this.canvas;
        
        // Cache scaling calculations
        if (!img._scaleCache || img._scaleCache.canvasWidth !== width || img._scaleCache.canvasHeight !== height) {
          const scale = Math.min(width / img.width, height / img.height);
          img._scaleCache = {
            scale,
            scaledWidth: img.width * scale,
            scaledHeight: img.height * scale,
            x: (width - img.width * scale) / 2,
            y: (height - img.height * scale) / 2,
            canvasWidth: width,
            canvasHeight: height
          };
        }
        
        const { scaledWidth, scaledHeight, x, y } = img._scaleCache;
        
        ctx.save();
        ctx.globalAlpha = alpha;
        
        // Batch filter applications
        const filters = [];
        if (this.settings.effects.has('motionblur') && effects.motionBlur) {
          filters.push('blur(2px)');
        }
        if (filters.length > 0) {
          ctx.filter = filters.join(' ');
        }
        
        ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
        ctx.filter = 'none';
        
        // Apply post-processing effects efficiently
        if (this.settings.effects.has('vignette')) {
          // Use cached vignette gradient
          if (!this._vignetteGradient || this._vignetteGradient.width !== width || this._vignetteGradient.height !== height) {
            this._vignetteGradient = ctx.createRadialGradient(
              width / 2, height / 2, 0,
              width / 2, height / 2, Math.max(width, height) / 2
            );
            this._vignetteGradient.addColorStop(0, 'rgba(0,0,0,0)');
            this._vignetteGradient.addColorStop(0.6, 'rgba(0,0,0,0)');
            this._vignetteGradient.addColorStop(1, 'rgba(0,0,0,0.6)');
            this._vignetteGradient.width = width;
            this._vignetteGradient.height = height;
          }
          
          ctx.fillStyle = this._vignetteGradient;
          ctx.fillRect(0, 0, width, height);
        }
        
        ctx.restore();
      }

      applyVignette(ctx, width, height) {
        const gradient = ctx.createRadialGradient(
          width / 2, height / 2, 0,
          width / 2, height / 2, Math.max(width, height) / 2
        );
        gradient.addColorStop(0, 'rgba(0,0,0,0)');
        gradient.addColorStop(0.6, 'rgba(0,0,0,0)');
        gradient.addColorStop(1, 'rgba(0,0,0,0.6)');
        
        ctx.save();
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      applyDepthBlur(ctx, width, height) {
        // Simple depth blur simulation
        const imageData = ctx.getImageData(0, 0, width, height);
        // Apply blur effect to edges
        ctx.save();
        ctx.filter = 'blur(1px)';
        ctx.globalCompositeOperation = 'multiply';
        ctx.putImageData(imageData, 0, 0);
        ctx.restore();
      }

      applyTransition(transition, progress, currentImg, nextImg) {
        const ctx = this.ctx;
        const { width, height } = this.canvas;
        
        ctx.clearRect(0, 0, width, height);
        
        switch (transition) {
          case 'crossfade':
            this.drawImageWithEffects(currentImg, 1 - progress);
            this.drawImageWithEffects(nextImg, progress);
            break;
            
          case 'slide-left':
            ctx.save();
            ctx.translate(-width * progress, 0);
            this.drawImageWithEffects(currentImg, 1);
            ctx.translate(width, 0);
            this.drawImageWithEffects(nextImg, 1);
            ctx.restore();
            break;
            
          case 'slide-right':
            ctx.save();
            ctx.translate(width * progress, 0);
            this.drawImageWithEffects(currentImg, 1);
            ctx.translate(-width, 0);
            this.drawImageWithEffects(nextImg, 1);
            ctx.restore();
            break;
            
          case 'slide-up':
            ctx.save();
            ctx.translate(0, -height * progress);
            this.drawImageWithEffects(currentImg, 1);
            ctx.translate(0, height);
            this.drawImageWithEffects(nextImg, 1);
            ctx.restore();
            break;
            
          case 'slide-down':
            ctx.save();
            ctx.translate(0, height * progress);
            this.drawImageWithEffects(currentImg, 1);
            ctx.translate(0, -height);
            this.drawImageWithEffects(nextImg, 1);
            ctx.restore();
            break;
            
          case 'zoom-in':
            const scale = 1 + progress * 0.5;
            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.scale(scale, scale);
            ctx.translate(-width / 2, -height / 2);
            this.drawImageWithEffects(currentImg, 1 - progress);
            ctx.restore();
            this.drawImageWithEffects(nextImg, progress);
            break;
            
          case 'zoom-out':
            const scaleOut = 1 - progress * 0.3;
            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.scale(scaleOut, scaleOut);
            ctx.translate(-width / 2, -height / 2);
            this.drawImageWithEffects(currentImg, 1 - progress);
            ctx.restore();
            this.drawImageWithEffects(nextImg, progress);
            break;
            
          case 'rotate':
            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.rotate(progress * Math.PI * 2);
            ctx.translate(-width / 2, -height / 2);
            this.drawImageWithEffects(currentImg, 1 - progress);
            ctx.restore();
            this.drawImageWithEffects(nextImg, progress);
            break;
            
          case 'blur':
            ctx.save();
            ctx.filter = `blur(${progress * 15}px)`;
            this.drawImageWithEffects(currentImg, 1);
            ctx.filter = 'none';
            ctx.restore();
            this.drawImageWithEffects(nextImg, progress);
            break;
            
          case 'pixelate':
            const pixelSize = Math.floor(progress * 30) + 1;
            ctx.save();
            ctx.imageSmoothingEnabled = false;
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width / pixelSize;
            tempCanvas.height = height / pixelSize;
            
            tempCtx.drawImage(this.canvas, 0, 0, tempCanvas.width, tempCanvas.height);
            ctx.drawImage(tempCanvas, 0, 0, width, height);
            ctx.restore();
            this.drawImageWithEffects(nextImg, progress);
            break;
            
          case 'glitch':
            this.drawImageWithEffects(currentImg, 1 - progress);
            if (Math.random() < progress * 0.3) {
              ctx.save();
              ctx.translate(Math.random() * 20 - 10, Math.random() * 20 - 10);
              ctx.globalCompositeOperation = 'screen';
              ctx.globalAlpha = 0.5;
              this.drawImageWithEffects(nextImg, 1);
              ctx.restore();
            }
            this.drawImageWithEffects(nextImg, progress);
            break;
            
          case 'wipe':
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, width * progress, height);
            ctx.clip();
            this.drawImageWithEffects(nextImg, 1);
            ctx.restore();
            
            ctx.save();
            ctx.beginPath();
            ctx.rect(width * progress, 0, width * (1 - progress), height);
            ctx.clip();
            this.drawImageWithEffects(currentImg, 1);
            ctx.restore();
            break;
            
          case 'iris':
            const radius = Math.max(width, height) * progress;
            ctx.save();
            ctx.beginPath();
            ctx.arc(width / 2, height / 2, radius, 0, Math.PI * 2);
            ctx.clip();
            this.drawImageWithEffects(nextImg, 1);
            ctx.restore();
            
            if (progress < 1) {
              ctx.save();
              ctx.beginPath();
              ctx.rect(0, 0, width, height);
              ctx.arc(width / 2, height / 2, radius, 0, Math.PI * 2, true);
              ctx.clip();
              this.drawImageWithEffects(currentImg, 1);
              ctx.restore();
            }
            break;
            
          default:
            this.drawImageWithEffects(currentImg, 1 - progress);
            this.drawImageWithEffects(nextImg, progress);
        }
      }

      renderFrame(time = 0) {
        if (this.images.length === 0) {
          if (!this._welcomeRendered) {
            this.renderWelcomeScreen();
            this._welcomeRendered = true;
          }
          return;
        }

        this._welcomeRendered = false;
        
        const totalDuration = this.settings.duration;
        const currentImageIndex = Math.floor(this.currentTime / totalDuration) % this.images.length;
        const nextImageIndex = (currentImageIndex + 1) % this.images.length;
        const timeInImage = this.currentTime % totalDuration;
        
        let transition = this.settings.transition;
        
        // Cache AI smart selection
        if (transition === 'ai-smart') {
          const cacheKey = `${currentImageIndex}-${nextImageIndex}`;
          if (!this._transitionCache) this._transitionCache = new Map();
          
          if (!this._transitionCache.has(cacheKey)) {
            this._transitionCache.set(cacheKey, this.selectSmartTransition(
              this.images[currentImageIndex], 
              this.images[nextImageIndex]
            ));
          }
          transition = this._transitionCache.get(cacheKey);
        }
        
        const isTransitioning = timeInImage >= totalDuration - this.settings.transitionDuration;
        
        if (isTransitioning) {
          const progress = (timeInImage - (totalDuration - this.settings.transitionDuration)) / this.settings.transitionDuration;
          this.applyTransition(transition, progress, this.images[currentImageIndex], this.images[nextImageIndex]);
        } else {
          // Skip clearing if same image is showing
          if (this._lastRenderedImage !== currentImageIndex) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.drawImageWithEffects(this.images[currentImageIndex], 1, { motionBlur: true });
            this._lastRenderedImage = currentImageIndex;
          }
        }
        
        // Throttle playhead updates
        if (!this._lastPlayheadUpdate || Date.now() - this._lastPlayheadUpdate > 100) {
          this.updatePlayhead();
          this._lastPlayheadUpdate = Date.now();
        }
      }

      animate = (time) => {
        if (!this.recordingStartTime) this.recordingStartTime = time;
        this.currentTime = (time - this.recordingStartTime) / 1000;
        
        this.renderFrame(time);
        
        // Throttle audio visualizer updates
        if (this.isRecording && this.analyserNode) {
          this.updateAudioVisualizer();
        }
        
        if (this.isRecording) {
          this.animationId = requestAnimationFrame(this.animate);
        }
      }

      async startGeneration() {
        if (this.images.length === 0) {
          this.updateStatus('⚠️', 'No images loaded', 'Please upload some images first');
          return;
        }

        this.isRecording = true;
        this.recordingStartTime = null;
        
        document.getElementById('startBtn').disabled = true;
        document.getElementById('stopBtn').disabled = false;
        document.getElementById('recordingIndicator').classList.add('active');
        document.getElementById('progressContainer').classList.add('visible');
        
        this.updateStatus('🎬', 'Generating video...', 'AI is processing your content');

        // Setup audio if available
        if (this.audioBuffer && this.audioCtx) {
          if (this.sourceNode) this.sourceNode.disconnect();
          this.sourceNode = this.audioCtx.createBufferSource();
          this.sourceNode.buffer = this.audioBuffer;
          this.sourceNode.connect(this.audioCtx.destination);
          
          if (this.analyserNode) {
            this.sourceNode.connect(this.analyserNode);
          }
          
          this.sourceNode.start(0);
        }

        // Start animation
        this.animationId = requestAnimationFrame(this.animate);

        // Setup recording
        const stream = this.canvas.captureStream(this.settings.fps);
        
        if (this.audioBuffer && this.audioCtx) {
          const dest = this.audioCtx.createMediaStreamDestination();
          if (this.sourceNode) this.sourceNode.connect(dest);
          
          const finalStream = new MediaStream([
            ...stream.getVideoTracks(),
            ...dest.stream.getAudioTracks()
          ]);
          stream = finalStream;
        }

        this.videoChunks = [];
        
        const mimeType = this.settings.format === 'webm' ? 'video/webm; codecs=vp9' : 'video/webm';
        this.mediaRecorder = new MediaRecorder(stream, {
          mimeType,
          videoBitsPerSecond: this.settings.bitrate * 1000000
        });

        this.mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) this.videoChunks.push(e.data);
        };

        this.mediaRecorder.onstop = () => this.handleRecordingComplete();

        this.mediaRecorder.start();
        this.startProgressSimulation();
      }

      stopGeneration() {
        if (!this.isRecording) return;
        
        this.isRecording = false;
        
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
          this.animationId = null;
        }

        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
          this.mediaRecorder.stop();
        }

        if (this.sourceNode) {
          this.sourceNode.stop();
          this.sourceNode.disconnect();
          this.sourceNode = null;
        }

        document.getElementById('startBtn').disabled = false;
        document.getElementById('stopBtn').disabled = true;
        document.getElementById('recordingIndicator').classList.remove('active');
        
        this.updateStatus('⏹️', 'Generation stopped', 'Video recording has been stopped');
      }

      async handleRecordingComplete() {
        this.updateStatus('🔄', 'Processing video...', 'Finalizing your masterpiece');
        
        const blob = new Blob(this.videoChunks, { 
          type: this.settings.format === 'webm' ? 'video/webm' : 'video/mp4' 
        });
        
        const url = URL.createObjectURL(blob);
        const downloadBtn = document.getElementById('downloadBtn');
        
        downloadBtn.onclick = () => {
          const a = document.createElement('a');
          a.href = url;
          a.download = `nexus-ai-video-${Date.now()}.${this.settings.format === 'webm' ? 'webm' : 'mp4'}`;
          a.click();
        };
        
        downloadBtn.style.display = 'block';
        document.getElementById('progressContainer').classList.remove('visible');
        
        this.updateStatus('✅', 'Video ready!', 'Your AI-generated video is ready for download');
      }

      startProgressSimulation() {
        let progress = 0;
        const progressFill = document.getElementById('progressFill');
        
        const updateProgress = () => {
          if (this.isRecording && progress < 95) {
            progress += Math.random() * 3;
            progressFill.style.width = `${Math.min(progress, 95)}%`;
            setTimeout(updateProgress, 200);
          }
        };
        
        updateProgress();
      }

      updateStatus(icon, text, subtext) {
        document.getElementById('statusIcon').textContent = icon;
        document.getElementById('statusText').textContent = text;
        document.getElementById('statusSubtext').innerHTML = subtext;
      }

      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
          
          switch(e.key) {
            case ' ':
              e.preventDefault();
              if (this.isRecording) {
                this.stopGeneration();
              } else {
                this.startGeneration();
              }
              break;
            case 'Escape':
              if (this.isRecording) {
                this.stopGeneration();
              }
              break;
            case 'Delete':
            case 'Backspace':
              if (this.images.length > 0) {
                this.removeImage(this.images.length - 1);
              }
              break;
          }
        });
      }
    }

    // Initialize the application
    let nexusStudio;
    
    document.addEventListener('DOMContentLoaded', () => {
      nexusStudio = new NexusAIStudio();
    });

    // Performance monitoring
    const performanceObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        if (entry.entryType === 'measure') {
          console.log(`${entry.name}: ${entry.duration.toFixed(2)}ms`);
        }
      });
    });

    performanceObserver.observe({ entryTypes: ['measure'] });

    // Service worker for offline functionality
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js').catch(() => {
        console.log('Service worker registration failed');
      });
    }

    console.log('🚀 Nexus AI Studio initialized successfully!');
  </script>
</body>
</html>
